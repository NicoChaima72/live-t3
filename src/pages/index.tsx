import Head from "next/head";
import { type FormEvent, useRef, useState, useEffect } from "react";
import { nanoid } from "nanoid";

interface Message {
  id: string;
  content: string;
  role: "user" | "assistant";
}

export default function Home() {
  const containerMessagesRef = useRef<HTMLDivElement>(null);
  const [input, setInput] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [messages, setMessages] = useState<Message[]>([]);

  useEffect(() => {
    if (containerMessagesRef.current) {
      containerMessagesRef.current.scrollTo({
        top: containerMessagesRef.current.scrollHeight,
        behavior: "smooth",
      });
    }
  }, [messages]);

  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault();

    setMessages((prev) => [
      ...prev,
      { id: nanoid(), content: input, role: "user" },
      { id: "temp", content: "", role: "assistant" },
    ]);

    setInput("");

    setIsLoading(true);

    const response = await fetch("/api/streaming", {
      method: "POST",
      body: JSON.stringify({ messages }),
      headers: {
        "Content-Type": "application/json",
      },
    });
    if (!response.ok) {
      throw new Error("Failed to fetch");
    }

    const data = response.body;
    if (!data) {
      throw new Error("No data received");
      return;
    }

    const reader = data.getReader();
    const decoder = new TextDecoder();
    let done = false;
    let tempValue = ""; // temporary value to store incomplete json strings

    while (!done) {
      const { value, done: doneReading } = await reader.read();
      done = doneReading;
      let chunkValue = decoder.decode(value);

      // if there is a temp value, prepend it to the incoming chunk
      if (tempValue) {
        chunkValue = tempValue + chunkValue;
        tempValue = "";
      }

      // match json string and extract it from the chunk
      const match = chunkValue.match(/\{(.*?)\}/);
      if (match) {
        tempValue = chunkValue.replace(match[0], "");
        chunkValue = match[0];
      }

      try {
        setMessages((prev) =>
          prev.map((m) =>
            m.id === "temp" ? { ...m, content: m.content + chunkValue } : m
          )
        );
        const data = chunkValue;
        /* do something with the data */
        console.log({ data });
      } catch (e) {
        // store the incomplete json string in the temporary value
        tempValue = chunkValue;
      }

      if (done) {
        console.log("Stream complete");
      }
    }

    setMessages((prev) =>
      prev.map((m) => (m.id === "temp" ? { ...m, id: nanoid() } : m))
    );
    setIsLoading(false);
    return true;
  };

  const handleInputChange = (e: FormEvent<HTMLInputElement>) => {
    setInput(e.currentTarget.value);
  };

  return (
    <>
      <Head>
        <title>Create T3 App</title>
        <meta name="description" content="Generated by create-t3-app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <div className="stretch mx-auto flex h-[95vh]  w-full max-w-md flex-col space-y-4 rounded-lg bg-white shadow-xl">
        <div className="px-6 pt-6">
          <h1 className="border-b border-gray-300 pb-2 text-2xl font-bold">
            Chat
          </h1>
        </div>
        <div
          className="flex-1 space-y-5 overflow-y-auto px-6 pt-2"
          ref={containerMessagesRef}
        >
          {messages.map((m, index) => (
            <div key={index}>
              <div className="flex items-center pb-1">
                <div
                  className={`mr-2 h-8 w-8 rounded-full ${
                    m.role === "user" ? "bg-gray-300" : "bg-gray-500"
                  }`}
                ></div>

                <p className="text-lg">{m.role === "user" ? "TÃº" : "AI"}</p>
              </div>

              {m.content.split("\n").map((line, i) => (
                <p className="mt-1" key={i}>
                  {line}
                </p>
              ))}
            </div>
          ))}
        </div>

        <form
          onSubmit={(e) => handleSubmit(e)}
          className="flex gap-2  px-6 pb-4"
        >
          <input
            className=" flex-1 rounded border border-gray-300 p-2"
            placeholder="Preguntar algo..."
            value={input}
            onChange={handleInputChange}
          />
          {!isLoading ? (
            <button
              type="submit"
              className="rounded bg-green-600 px-4 text-white hover:bg-green-700"
            >
              Enviar
            </button>
          ) : (
            <button
              type="button"
              className="rounded bg-red-600 px-4 text-white hover:bg-red-700"
              onClick={stop}
            >
              Cancelar
            </button>
          )}
        </form>
      </div>
    </>
  );
}
